<?xml version="1.0" encoding="UTF-8"?>
<refentry version="5.0-subset Scilab" xml:id="symphony" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:ns3="http://www.w3.org/1999/xhtml"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:db="http://docbook.org/ns/docbook">

  <refnamediv>
    <refname>symphony</refname>

    <refpurpose>solve a mixed integer linear programming problem</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>[xmin,fmin,status,extra] = symphony(c1,c2,A,lhs,rhs,lb,ub,btype,vartype,options)</synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Parameters</title>

    <para>Input parameters:</para>

    <variablelist>
      <varlistentry>
        <term>c1</term>

        <listitem>
          <para>a vector representing the coefficients of the first objective
          function.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>c2</term>

        <listitem>
          <para>a vector representing the coefficients of the second
          (optional) objective function.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>A</term>

        <listitem>
          <para>a matrix (sparse of not) representing the coefficients of the
          constraints.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>lhs</term>

        <listitem>
          <para>the left hand side column vector which containts the upper
          bounds of the constraints. This vector is optional.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>rhs</term>

        <listitem>
          <para>the right hand side column vector which containts the lower
          bounds of the constraints. This vector is optional.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>lb</term>

        <listitem>
          <para>the vector containing the lower bounds for the
          variables.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>ub</term>

        <listitem>
          <para>the vector containing the upper bounds for the
          variables.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>btype</term>

        <listitem>
          <para>a string containing the type of bounds for the constraints. If
          there are N constraints, then btype must be of length N. The meaning
          of the characters are the following:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>'L'</emphasis> - smaller than - &lt;=</para>
            </listitem>

            <listitem>
              <para><emphasis>'E'</emphasis> - equality - =</para>
            </listitem>

            <listitem>
              <para><emphasis>'G'</emphasis> - greater than - &gt;=</para>
            </listitem>

            <listitem>
              <para><emphasis>'R'</emphasis> - Range - &lt;= + &gt;=</para>
            </listitem>

            <listitem>
              <para><emphasis>'N'</emphasis> - Free - no constraints.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>vartype</term>

        <listitem>
          <para>a string containing the type of variables. If there are N
          variables, then btype must be of length N. This parameters must
          contains:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>'C', 'c'</emphasis> - for a continuous
              variable</para>
            </listitem>

            <listitem>
              <para><emphasis>'I', 'i'</emphasis> - for a binary or integer
              variable</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>options</term>

        <listitem>
          <para>a parameters list (which is initialized via
          init_param).</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Output parameters</para>

    <variablelist>
      <varlistentry>
        <term>xmin</term>

        <listitem>
          <para>the solution found by symphony.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>fmin</term>

        <listitem>
          <para>the value of the objective function.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>status</term>

        <listitem>
          <para>an integer which gives informations related to the termination
          of the solver:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>-100</emphasis>: ERROR__USER</para>
            </listitem>

            <listitem>
              <para><emphasis>225</emphasis>: TM_NO_PROBLEM</para>
            </listitem>

            <listitem>
              <para><emphasis>226</emphasis>: TM_NO_SOLUTION</para>
            </listitem>

            <listitem>
              <para><emphasis>227</emphasis>: TM_OPTIMAL_SOLUTION_FOUND</para>
            </listitem>

            <listitem>
              <para><emphasis>228</emphasis>: TM_TIME_LIMIT_EXCEEDED</para>
            </listitem>

            <listitem>
              <para><emphasis>229</emphasis>: TM_NODE_LIMIT_EXCEEDED</para>
            </listitem>

            <listitem>
              <para><emphasis>230</emphasis>: TM_TARGET_GAP_ACHIEVED</para>
            </listitem>

            <listitem>
              <para><emphasis>231</emphasis>: TM_FOUND_FIRST_FEASIBLE</para>
            </listitem>

            <listitem>
              <para><emphasis>232</emphasis>: TM_FINISHED</para>
            </listitem>

            <listitem>
              <para><emphasis>233</emphasis>: TM_UNFINISHED</para>
            </listitem>

            <listitem>
              <para><emphasis>234</emphasis>:
              TM_FEASIBLE_SOLUTION_FOUND</para>
            </listitem>

            <listitem>
              <para><emphasis>235</emphasis>: TM_SIGNAL_CAUGHT</para>
            </listitem>

            <listitem>
              <para><emphasis>-250</emphasis>:
              TM_ERROR__NO_BRANCHING_CANDIDATE</para>
            </listitem>

            <listitem>
              <para><emphasis>-251</emphasis>:
              TM_ERROR__ILLEGAL_RETURN_CODE</para>
            </listitem>

            <listitem>
              <para><emphasis>-252</emphasis>:
              TM_ERROR__NUMERICAL_INSTABILITY</para>
            </listitem>

            <listitem>
              <para><emphasis>-253</emphasis>: TM_ERROR__COMM_ERROR</para>
            </listitem>

            <listitem>
              <para><emphasis>-275</emphasis>: TM_ERROR__USER</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>extra</term>

        <listitem>
          <para>a parameter list which gather some more informations related
          to the state of the solver.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The parameters used by the symphony 'options' input structure are
    the following:</para>

    <para>Global parameters:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>'verbosity'</emphasis> - integer (default value: 0).
        Sets the verbosity of all modules to the given value. In general, the
        greater this number the more verbose each module is.</para>
      </listitem>

      <listitem>
        <para><emphasis>'random_seed'</emphasis> - integer (default value:17).
        A random seed.</para>
      </listitem>

      <listitem>
        <para><emphasis>'granularity'</emphasis> - double (default value:
        1e-6). Should be set to 'the minimum difference between two distinct
        objective function values' less the epsilon tolerance. E.g., if every
        variable is integral and the objective coefficients are integral then
        for any feasible solution the objective value is integer, so
        granularity could be correctly set to .99999.</para>
      </listitem>

      <listitem>
        <para><emphasis>'upper_bound'</emphasis> - double (default value:
        none) . The value of the best known upper bound.</para>
      </listitem>

      <listitem>
        <para><emphasis>'lower_bound'</emphasis> - double (default value:
        none). This parameter is used if the user wants to artificially impose
        a lower bound.</para>
      </listitem>

      <listitem>
        <para><emphasis>'probname'</emphasis> - string (default value: empty
        string). The name of the problem name.</para>
      </listitem>

      <listitem>
        <para><emphasis>'infile_name'</emphasis> - string (default value:
        empty string). The name of the input file that was read by '-F' or the
        '-L' flag (using the standalone symphony executable).</para>
      </listitem>

      <listitem>
        <para><emphasis>'writemps'</emphasis> - string ('test.mps'). The name
        of the output file generated (if the option is present).</para>
      </listitem>
    </itemizedlist>

    <para>Master module parameters:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>'M_verbosity'</emphasis> - integer (0). Sets the
        verbosity of the Master module to the given value.</para>
      </listitem>

      <listitem>
        <para><emphasis>'M_random_seed'</emphasis> - integer (17). A random
        seed just for the Master module.</para>
      </listitem>

      <listitem>
        <para>'upper_bound_estimate' - double (no estimate). This parameter is
        used if the user wants to provide an estimate of the optimal value
        which will help guide the search. This is used in conjunction with the
        diving strategy BEST ESTIMATE - 0.</para>
      </listitem>

      <listitem>
        <para><emphasis>'tm_exe', 'dg_exe'</emphasis> - strings ('tm', 'dg').
        The name of the executable files of the TM and DG modules. Note that
        the TM executable name may have extensions that depend on the
        configuration of the modules, but the default is always set to the
        file name produced by the makefile. If you change the name of the
        treemanager executable from the default, you must set this parameter
        to the new name.</para>
      </listitem>

      <listitem>
        <para><emphasis>'tm_debug', 'dg_debug'</emphasis> - boolean (both
        FALSE). Whether these modules should be started under a debugger or
        not (see 5.6.2 of the Symphony library documentation for more details
        on this).</para>
      </listitem>

      <listitem>
        <para><emphasis>'tm_machine'</emphasis> - string (empty string). On
        which processor of the virtual machine the TM should be run. Leaving
        this parameter as an empty string means arbitrary selection.</para>
      </listitem>

      <listitem>
        <para><emphasis>'do_draw_graph'</emphasis> - boolean (FALSE). Whether
        to start up the DG module or not (see Section 5.6.4 of the Symphony
        library documentation for an introduction to this).</para>
      </listitem>

      <listitem>
        <para><emphasis>'do_branch_and_cut'</emphasis> - boolean (TRUE).
        Whether to run the branch and cut algorithm or not. (Set this to FALSE
        to run the user's heuristics only.)</para>
      </listitem>

      <listitem>
        <para>'mc_search_order' - integer (MC_FIFO - 0). Use the fifo (MC_FIFO
        - 0) or lifo (MC_LIFO - 1) searh order during the multi criteria
        solution procedure.</para>
      </listitem>

      <listitem>
        <para><emphasis>'mc_warm_start'</emphasis> - boolean (FALSE - 0).
        Whether to solve the corresponding problem of each iteration from a
        warm start loaded from a base iteration (which is the first iteration
        where gamma = 1.0 and tau = 0.0) or from scratch. Currently, this
        option is supported if only the supported solutions are desired to be
        found.</para>
      </listitem>

      <listitem>
        <para><emphasis>'trim_warm_tree'</emphasis> - boolean (FALSE - 0).
        Whether to trim the warm start tree before re-solving. This consists
        of locating nodes whose descendants are all likely to be pruned in the
        resolve and eliminating those descendants in favor of processing the
        parent node itself.</para>
      </listitem>

      <listitem>
        <para><emphasis>'mc_compare_solution_tolerance'</emphasis> - double
        (0.001). If the difference between the objective values of two
        solutions to be compared, during the bicriteria solution procedure,
        are less than this tolerance, then assume them to be equal.</para>
      </listitem>

      <listitem>
        <para><emphasis>'mc_binary_search_tolerance'</emphasis> - double (0).
        The tolerance to be used to differentiate the gamma values if binary
        search is used during the bicriteria solution procedure. A value
        greater than zero will cause the binary search to be activated.</para>
      </listitem>
    </itemizedlist>

    <para>Tree manager parameters:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>'TM_verbosity'</emphasis> - integer (0). The verbosity
        of the TM module.</para>
      </listitem>

      <listitem>
        <para><emphasis>'lp_exe', 'cg_exe', 'cp_exe'</emphasis> - strings
        ('lp', 'cg', 'cp'). The name of the LP, CG, and CP module binaries.
        Note: when running in parallel using PVM, these executables (or links
        to them) must reside in the PVM_ROOT/bin/PVM_ARCH/ directory. Also, be
        sure to note that the executable names may have extensions that depend
        on the configuration of the modules, but the defaults will always be
        set to the name that the makefile produces.</para>
      </listitem>

      <listitem>
        <para><emphasis>'lp_debug', 'cg_debug', 'cp_debug'</emphasis> -
        boolean (all FALSE - 0). Whether the modules should be started under a
        debugger or not.</para>
      </listitem>

      <listitem>
        <para><emphasis>'max_active_nodes'</emphasis> - integer (1). The
        maximum number of active search tree nodes equal to the number of LP
        and CG tandems to be started up.</para>
      </listitem>

      <listitem>
        <para><emphasis>'max_cp_num'</emphasis> - integer (0). The maximum
        number of cut pools to be used.</para>
      </listitem>

      <listitem>
        <para><emphasis>'lp_mach_num', 'cg_mach_num', 'cp_mach_num'</emphasis>
        - integers (all 0). The number of processors in the virtual machine to
        run LP (CG, CP) processes. If this value is 0 then the processes will
        be assigned to processors in round-robin order. Otherwise the next xx
        mach num lines describe the processors where the LP (CG, CP) modules
        must run. The keyword value pairs on these lines must be TM xx machine
        and the name or IP address of a processor (the processor names need
        not be distinct). In this case the actual processes are assigned in a
        round robin fashion to the processors on this list. This feature is
        useful if a specific software package is needed for some module, but
        that software is not licensed for every node of the virtual machine or
        if a certain process must run on a certain type of machine due to
        resource requirements.</para>
      </listitem>

      <listitem>
        <para><emphasis>'use_cg'</emphasis> - boolean (FALSE - 0). Whether to
        use a cut generator or not.</para>
      </listitem>

      <listitem>
        <para><emphasis>'TM_random_seed'</emphasis> - integer (17). The random
        seed used in the TM.</para>
      </listitem>

      <listitem>
        <para><emphasis>'unconditional_dive_frac'</emphasis> - double (0.0).
        The fraction of the nodes on which SYMPHONY randomly dives
        unconditionally into one of the children.</para>
      </listitem>

      <listitem>
        <para>'diving_strategy' - integer (BEST_ESTIMATE - 0). The strategy
        employed when deciding whether to dive or not. The BEST_ESTIMATE - 0
        strategy continues to dive until the lower bound in the child to be
        dived into exceeds the parameter upper_bound_estimate, which is given
        by the user. The COMP_BEST_K - 1 strategy computes the average lower
        bound on the best diving_k search tree nodes and decides to dive if
        the lower bound of the child to be dived into does not exceed this
        average by more than the fraction diving_threshold. The
        COMP_BEST_K_GAP - 2 strategy takes the size of the gap into account
        when deciding whether to dive. After the average lower bound of the
        best diving_k nodes is computed, the gap between this average lower
        bound and the current upper bound is computed. Diving only occurs if
        the difference between the computed average lower bound and the lower
        bound of the child to be dived into is at most the fraction
        diving_threshold of the gap. Note that fractional diving settings can
        override these strategies. See below.</para>
      </listitem>

      <listitem>
        <para><emphasis>'diving_k', 'diving_threshold'</emphasis> - integer,
        double (1, 0.05). See above.</para>
      </listitem>

      <listitem>
        <para><emphasis>'fractional_diving_ratio', 'fractional_diving_num'
        </emphasis>- integer (0.02, 0). Diving occurs automatically if the
        number of fractional variables in the child to be dived into is less
        than fractional diving num or the fraction of total variables that are
        fractional is less than fractional_diving_ratio. This overrides the
        other diving rules. Note that in order for this option to work, the
        code must be compiled with FRACTIONAL_BRANCHING defined. This is the
        default. See the makefile of Symphony for more details.</para>
      </listitem>

      <listitem>
        <para><emphasis>'node_selection_rule'</emphasis> - integer
        (LOWEST_LP_FIRST - 0). The rule for selecting the next search tree
        node to be processed. This rule selects the one with lowest lower
        bound. Other possible values are:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>1</emphasis> - HIGHEST_LP_FIRST</para>
          </listitem>

          <listitem>
            <para><emphasis>2</emphasis> - BREADTH_FIRST_SEARCH</para>
          </listitem>

          <listitem>
            <para><emphasis>3</emphasis> - DEPTH_FIRST_SEARCH</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para><emphasis>'load_balance_level'</emphasis> - integer (-1) A naive
        attempt at load balancing on problems where significant time is spent
        in the root node, contributing to a lack of parallel speed-up. Only a
        prescribed number of iterations (load balance iter) are performed in
        the root node (and in each subsequent node on a level less than or
        equal to load_balance_level) before branching is forced in order to
        provide additional subproblems for the idle processors to work on.
        This doesn't work well in general.</para>
      </listitem>

      <listitem>
        <para><emphasis>'load_balance_iter'</emphasis> - integer (-1) Works in
        tandem with the load_balance_level to attempt some simple load
        balancing. See the above description.</para>
      </listitem>

      <listitem>
        <para><emphasis>'keep_description_of_pruned'</emphasis> - integer
        (DISCARD - 0). Whether to keep the description of pruned search tree
        nodes or not. The reasons to do this are:</para>

        <orderedlist>
          <listitem>
            <para>if the user wants to write out a proof of optimality using
            the logging function,</para>
          </listitem>

          <listitem>
            <para>for debugging, or</para>
          </listitem>

          <listitem>
            <para>to get a visual picture of the tree using the software
            VBCTOOL.</para>
          </listitem>
        </orderedlist>

        <para>Otherwise, keeping the pruned nodes around just takes up memory.
        There are three options if it is desired to keep some description of
        the pruned nodes around. First, their full description can be written
        out to disk and freed from memory (KEEP_ON_DISK_FULL - 1). There is
        not really too much you can do with this kind of file, but
        theoretically, it contains a full record of the solution process and
        could be used to provide a certificate of optimality (if we were using
        exact arithmetic) using an independent verifier. In this case, the
        line following keep_description_of_pruned should be a line containing
        the keyword pruned_node_file_name with its corresponding value being
        the name of a file to which a description of the pruned nodes can be
        written. The file does not need to exist and will be over-written if
        it does exist. If you have the software VBCTOOL, then you can
        alternatively just write out the information VBCTOOL needs to display
        the tree (KEEP_ON_DISK_VBC_TOOL - 2). Finally, the user can set the
        value to of this parameter to KEEP_IN_MEMORY - 3, in which case all
        pruned nodes will be kept in memory and written out to the regular log
        file if that option is chosen. This is really only useful for
        debugging. Otherwise, pruned nodes should be flushed.</para>
      </listitem>

      <listitem>
        <para><emphasis>'keep_warm_start'</emphasis> - boolean (FALSE - 0).
        Turning this parameter on will have exactly the same impact with
        setting the keep_description_of_pruned to KEEP_IN_MEMORY - 3. This
        will allow SYMPHONY to keep all the necessary information obtained
        from the branching tree of the original problem to be able to warm
        start after a parameter or problem data modification. Thus, if it is
        intended to warm start later, the user should set this parameter
        before solving the original problem.</para>
      </listitem>

      <listitem>
        <para><emphasis>'warm_start_node_limit'</emphasis> - integer
        (SYM_INFINITY - 100000000). Setting this parameter will start the warm
        start routine using only the first warm_start_node_limit nodes
        generated during the previous solve procedure. The rest of the tree
        will be trimmed.</para>
      </listitem>

      <listitem>
        <para><emphasis>'warm_start_node_ratio'</emphasis> - double (0.0).
        Setting this parameter will start the warm start routine using only
        the first warm_start_node_ratio% of the nodes generated during the
        previous solve procedure.</para>
      </listitem>

      <listitem>
        <para><emphasis>'warm_start_node_level'</emphasis> - integer
        (SYM_INFINITY = 100000000). Setting this parameter will start the warm
        start routine using all the nodes above the level
        warm_start_node_level of the tree generated during the previous solve
        procedure. The rest of the tree will be trimmed.</para>
      </listitem>

      <listitem>
        <para><emphasis>'warm_start_node_level_ratio'</emphasis> - double
        (0.0). Setting this parameter will start the warm start routine using
        all the nodes above the level warm_start_node_level% of the warm start
        tree depth. The rest of the tree will be trimmed.</para>
      </listitem>

      <listitem>
        <para><emphasis>'logging'</emphasis> - integer (NO_LOGGING - 0).
        Whether or not to write out the state of the search tree and all other
        necessary data to disk periodically in order to allow a warm start in
        the case of a system crash or to allow periodic viewing with VBCTOOL.
        If the value of this parameter is set to FULL_LOGGING - 1, then all
        information needed to warm start the calculation will written out
        periodically. The next two lines of the parameter file following
        should contain the keywords tree_log_file_name and cut_log_file_name
        along with corresponding file names as values. These will be the files
        used to record the search tree and related data and the list of cuts
        needed to reconstruct the tree. If the value of the parameter is set
        to VBC_TOOL - 2, then only the information VBCTOOL needs to display
        the tree will be logged. This is not really a very useful option since
        a 'live' picture of the tree can be obtained using the vbc_emulation
        parameter described below.</para>
      </listitem>

      <listitem>
        <para><emphasis>'logging_interval'</emphasis> - integer (1800).
        Interval (in seconds) between writing out the above log files.</para>
      </listitem>

      <listitem>
        <para><emphasis>'warm_start'</emphasis> - boolean (0). Used to allow
        the tree manager to make a warm start by reading in previously written
        log files. If this option is set, then the two line following must
        start with the keywords warm_start_tree_file_name and
        warm_start_cut_file_name and include the appropriate file names as the
        corresponding values.</para>
      </listitem>

      <listitem>
        <para><emphasis>'vbc_emulation' </emphasis>- integer (NO_VBC_EMULATION
        - 0) Determines whether or not to employ the VBCTOOL emulation mode.
        If one of these modes is chosen, then the tree will be displayed in
        'real time' using the VBCTOOL Software. When using the option
        VBC_EMULATION_LIVE - 2 and piping the output directly to VBCTOOL, the
        tree will be displayed as it is constructed, with color coding
        indicating the status of each node. With VBC_EMULATION_FILE - 1
        selected, a log file will be produced which can later be read into
        VBCTOOL to produce an emulation of the solution process at any desired
        speed. If VBC_EMULATION_FILE - 1 is selected, the the following line
        should contain the keyword vbc_emulation_file_name along with the
        corresponding file name for a value.</para>
      </listitem>

      <listitem>
        <para><emphasis>'price_in_root'</emphasis> - boolean (FALSE - 0).
        Whether to price out variables in the root node before the second
        phase starts (called repricing the root).</para>
      </listitem>

      <listitem>
        <para><emphasis>'trim_search_tree'</emphasis> - boolean (FALSE - 0).
        Whether to trim the search tree before the second phase starts or not.
        Useful only if there are two phases. (It is very useful then).</para>
      </listitem>

      <listitem>
        <para><emphasis>'colgen_in_first_phase',
        'colgen_in_second_phase'</emphasis> - integers (both 4). These
        parameters determine if and when to do column generation in the first
        and second phase of the algorithm. The value of each parameter is
        obtained by setting the last four bits. The last two bits refer to
        what to do when attempting to prune a node. If neither of the last two
        bits are set, then we don't do anything we just prune it. If only the
        last bit is set, then we simply save the node for the second phase
        without doing any column generation (yet). If only the second to last
        bit is set, then we do column generation immediately and resolve if
        any new columns are found. The next two higher bits determine whether
        or not to do column generation before branching. If only the third
        lowest bit is set, then no column generation occurs before branching.
        If only the fourth lowest bit is set, then column generation is
        attempted before branching. The default is not to generate columns
        before branching or fathoming, which corresponds to only the third
        lowest bit being set, resulting in a default value of 4.</para>
      </listitem>

      <listitem>
        <para><emphasis>'time_limit'</emphasis> - double (-1.0). Number of
        seconds of wall-clock time allowed for solution. When this time limit
        is reached, the solution process will stop and the best solution found
        to that point, along with other relevant data, will be output. A time
        limit less than 0.0 means there is no limit.</para>
      </listitem>

      <listitem>
        <para><emphasis>'node_limit'</emphasis> - integer (-1). Number of
        nodes allowed to be analyzed during the solution. When this node limit
        is reached, the solution process will stop and the best solution found
        to that point, along with other relevant data, will be output. A node
        limit less than 0 means there is no limit.</para>
      </listitem>

      <listitem>
        <para><emphasis>'gap_limit'</emphasis> - double (-1.0). Target gap
        limit allowed for solution. When the gap between the lower and the
        upper bound reaches this point, the solution process will stop and the
        best solution found to that point, along with other relevant data,
        will be output. A gap limit less than 0 means there is no
        limit.</para>
      </listitem>

      <listitem>
        <para><emphasis>'find_first_feasible'</emphasis> - boolean (FALSE -
        0). Whether to stop after finding the first feasible solution or
        not.</para>
      </listitem>

      <listitem>
        <para><emphasis>'sensitivity_analysis' </emphasis>- boolean (FALSE -
        0). If the user wants to do the rudimentary sensitivity analysis,
        which will give a lower bound for the problem modified by the right
        hand side, then, this parameter has to be set before solving the
        original problem. If it is set, SYMPHONY will keep the necessary
        information from the solution processes of the original problem to be
        able to do the sensitivity analysis later.</para>
      </listitem>
    </itemizedlist>

    <para>LP Parameters:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>'LP_verbosity'</emphasis> - integer (0). Verbosity
        level of the LP module.</para>
      </listitem>

      <listitem>
        <para>'set_obj_upper_lim' - boolean (FALSE - 0). Whether to stop
        solving the LP relaxation when it's optimal value is provably higher
        than the global upper bound. There are some advantages to continuing
        the solution process anyway. For instance, this results in the highest
        possible lower bound. On the other hand, if the matrix is full, this
        node will be pruned anyway and the rest of the computation is
        pointless. This option should be set at FALSE - 0 for column
        generation since the LP dual values may not be reliable
        otherwise.</para>
      </listitem>

      <listitem>
        <para><emphasis>'try_to_recover_from_error' </emphasis>- boolean (TRUE
        - 1). Indicates what should be done in case the LP solver is unable to
        solve a particular LP relaxation because of numerical problems. It is
        possible to recover from this situation but further results may be
        suspect. On the other hand, the entire solution process can be
        abandoned.</para>
      </listitem>

      <listitem>
        <para><emphasis>'problem_type'</emphasis> - integer (ZERO_ONE_PROBLEM
        - 0). The type of problem being solved. Other values are
        INTEGER_PROBLEM - 1 or MIXED_INTEGER_PROBLEM - 2. (Caution: The
        mixed-integer option is not well tested)</para>
      </listitem>

      <listitem>
        <para><emphasis>'cut_pool_check_frequency'</emphasis> - integer (10).
        The number of iterations between sending LP solutions to the cut pool
        to find violated cuts. It is not advisable to check the cut pool too
        frequently as the cut pool module can get bogged down and the LP
        solution generally do not change that drastically from one iteration
        to the next anyway.</para>
      </listitem>

      <listitem>
        <para><emphasis>'not_fixed_storage_size'</emphasis> - integer (2048).
        The not fixed list is a partial list of indices of variables not in
        the matrix that have not been fixed by reduced cost. Keeping this list
        allows SYMPHONY to avoid repricing variables (an expensive operation)
        that are not in the matrix because they have already been permanently
        fixed. When this array reaches its maximum size, no more variable
        indices can be stored. It is therefore advisable to keep the maximum
        size of this array as large as possible, given memory
        limitations.</para>
      </listitem>

      <listitem>
        <para><emphasis>'max_non_dual_feas_to_add_min',
        'max_non_dual_feas_to_add_max',
        'max_non_dual_feas_to_add_frac'</emphasis> - integer, integer, double
        (20, 200, .05). These three parameters determine the maximum number of
        non-dual-feasible columns that can be added in any one iteration after
        pricing. This maximum is set to the indicated fraction of the current
        number of active columns unless this numbers exceeds the given maximum
        or is less than the given minimum, in which case, it is set to the max
        or min, respectively.</para>
      </listitem>

      <listitem>
        <para><emphasis> 'max_not_fixable_to_add_min',
        'max_not_fixable_to_add_max', 'max_not_fixable_to_add_frac'</emphasis>
        - integer, integer, double (100, 500, .1) As above, these three
        parameters determine the maximum number of new columns to be added to
        the problem because they cannot be priced out. These variables are
        only added when trying to restore infeasibility and usually, this does
        not require many variables anyway.</para>
      </listitem>

      <listitem>
        <para><emphasis>'mat_col_compress_num',
        'mat_col_compress_ratio'</emphasis> - integer, double (50, .05).
        Determines when the matrix should be physically compressed. This only
        happens when the number of columns is high enough to make it
        "worthwhile". The matrix is physically compressed when the number of
        deleted columns exceeds either an absolute number and a specified
        fraction of the current number of active columns.</para>
      </listitem>

      <listitem>
        <para><emphasis>'mat_row_compress_num', 'mat_row_compress_ratio'
        </emphasis>- integer, double (20, .05). Same as above except for
        rows.</para>
      </listitem>

      <listitem>
        <para><emphasis>'tailoff_gap_backsteps', 'tailoff_gap_frac'</emphasis>
        - integer, double (2, .99). Determines when tailoff is detected in the
        LP module. Tailoff is reported if the average ratio of the current gap
        to the previous iteration's gap over the last tailoff_gap_backsteps
        iterations wasn't at least tailoff_gap_frac.</para>
      </listitem>

      <listitem>
        <para><emphasis>'tailoff_obj_backsteps', 'tailoff_obj_frac'</emphasis>
        - integer, double (2, .99). Same as above, only the ratio is taken
        with respect to the change in objective function values instead of the
        change in the gap.</para>
      </listitem>

      <listitem>
        <para><emphasis>'ineff_cnt_to_delete'</emphasis> - integer (0).
        Determines after how many iterations of being deemed ineffective a
        constraint is removed from the current relaxation.</para>
      </listitem>

      <listitem>
        <para><emphasis>'eff_cnt_before_cutpool'</emphasis> - integer (3).
        Determines after how many iterations of being deemed effective each
        cut will be sent to the global pool.</para>
      </listitem>

      <listitem>
        <para><emphasis>'ineffective_constraints'</emphasis> - integer
        (BASIC_SLACKS_ARE_INEFFECTIVE - 2). Determines under what condition a
        constraint is deemed ineffective in the current relaxation. Other
        possible values are:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>0</emphasis> -
            NO_CONSTRAINT_IS_INEFFECTIVE,</para>
          </listitem>

          <listitem>
            <para><emphasis>1</emphasis> -
            NONZERO_SLACKS_ARE_INEFFECTIVE,</para>
          </listitem>

          <listitem>
            <para><emphasis>3</emphasis> -
            ZERO_DUAL_VALUES_ARE_INEFFECTIVE</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para><emphasis>'base_constraints_always_effective' </emphasis>-
        boolean (TRUE - 1). Determines whether the base constraints can ever
        be removed from the relaxation. In some case, removing the base
        constraints from the problem can be disastrous depending on the
        assumptions made by the cut generator.</para>
      </listitem>

      <listitem>
        <para><emphasis>'branch_on_cuts'</emphasis> - boolean (FALSE - 0).
        This informs the framework whether the user plans on branching on cuts
        or not. If so, there is additional bookkeeping to be done, such as
        maintaining a pool of slack cuts to be used for branching. Therefore,
        the user should not set this flag unless he actually plans on using
        this feature.</para>
      </listitem>

      <listitem>
        <para><emphasis>'discard_slack_cuts' </emphasis>- integer
        (DISCARD_SLACKS_BEFORE_NEW_ITERATION - 0). Determines when the pool of
        slack cuts is discarded. The other option is
        DISCARD_SLACKS_WHEN_STARTING_NEW_NODE - 1.</para>
      </listitem>

      <listitem>
        <para><emphasis>'first_lp_first_cut_time_out',
        'first_lp_all_cuts_time_out', 'later_lp_first_cut_time_out',
        'later_lp_all_cuts_time_out'</emphasis> - double (0, 0, 5, 1). The
        next group of parameters determines when the LP should give up waiting
        for cuts from the cut generator and start to solve the relaxation in
        its current form or possibly branch if necessary. There are two
        factors that contribute to determining this timeout. First is whether
        this is the first LP in the search node of whether it is a later LP.
        Second is whether any cuts have been added already in this iteration.
        The four timeout parameters correspond to the four possible
        combinations of these two variables.</para>
      </listitem>

      <listitem>
        <para><emphasis>'no_cut_timeout'</emphasis> This keyword does not have
        an associated value. If this keyword appears on a line by itself or
        with a value, this tells the framework not to time out while waiting
        for cuts. This is useful for debugging since it enables runs with a
        single LP module to be duplicated.</para>
      </listitem>

      <listitem>
        <para><emphasis>'all_cut_timeout'</emphasis> - double (no default).
        This keyword tells the framework to set all of the above timeout
        parameters to the value indicated.</para>
      </listitem>

      <listitem>
        <para><emphasis>'max_cut_num_per_iter'</emphasis> - integer (20). The
        maximum number of cuts that can be added to the LP in an iteration.
        The remaining cuts stay in the local pool to be added in subsequent
        iterations, if they are strong enough.</para>
      </listitem>

      <listitem>
        <para><emphasis>'do_reduced_cost_fixing' </emphasis>- boolean (FALSE -
        0). Whether or not to attempt to fix variables by reduced cost. This
        option is highly recommended</para>
      </listitem>

      <listitem>
        <para><emphasis>'gap_as_ub_frac', 'gap_as_last_gap_frac'</emphasis> -
        double (.1, .7). Determines when reduced cost fixing should be
        attempted. It is only done when the gap is within the fraction gap as
        ub frac of the upper bound or when the gap has decreased by the
        fraction gap as last gap frac since the last time variables were
        fixed.</para>
      </listitem>

      <listitem>
        <para><emphasis>'do_logical_fixing'</emphasis> - boolean (FALSE - 0).
        Determines whether the user's logical fixing routine should be
        used.</para>
      </listitem>

      <listitem>
        <para><emphasis>'fixed_to_ub_before_logical_fixing',
        'fixed_to_ub_frac_before_logical_fixing'</emphasis> - integer, double
        (1, .01). Determines when logical fixing should be attempted. It will
        be called only when a certain absolute number and a certain number of
        variables have been fixed to their upper bounds by reduced cost. This
        is because it is typically only after fixing variables to their upper
        bound that other variables can be logically fixed.</para>
      </listitem>

      <listitem>
        <para><emphasis>'max_presolve_iter' </emphasis>- integer (10). Number
        of simplex iterations to be performed in the presolve for strong
        branching.</para>
      </listitem>

      <listitem>
        <para><emphasis>'strong_branching_cand_num_max',
        'strong_branching_cand_num_min',
        'strong_branching_red_ratio'</emphasis> - integer (10, 5, 1). These
        three parameters together determine the number of strong branching
        candidates to be used by default. In the root node,
        strong_branching_cand_num_max candidates are used. On each succeeding
        level, this number is reduced by the number strong_branching_red_ratio
        multiplied by the square of the level. This continues until the number
        of candidates is reduced to strong_branching_cand_num_min and then
        that number of candidates is used in all lower levels of the
        tree.</para>
      </listitem>

      <listitem>
        <para><emphasis>'is_feasible_default' </emphasis>- integer
        (TEST_INTEGRALITY - 1). Determines the default test to be used to
        determine feasibility. This parameter is provided so that the user can
        change the default behavior without recompiling. The only other option
        is TEST_ZERO_ONE - 0.</para>
      </listitem>

      <listitem>
        <para><emphasis>'send_feasible_solution_default'</emphasis> - integer
        (SEND_NONZEROS - 0). Determines the form in which to send the feasible
        solution. This parameter is provided so that the user can change the
        default behavior without recompiling. This is currently the only
        option.</para>
      </listitem>

      <listitem>
        <para><emphasis>'send_lp_solution_default'</emphasis> - integer
        (SEND_NONZEROS - 0). Determines the default form in which to send the
        LP solution to the cut generator and cut pool. This parameter is
        provided so that the user can change the default behavior without
        recompiling. The other option is SEND_FRACTIONS - 1.</para>
      </listitem>

      <listitem>
        <para><emphasis>'display_solution_default'</emphasis> - integer
        (DISP_NOTHING - 0). Determines how to display the current LP solution
        if desired. See the description of user display solution() for other
        possible values. This parameter is provided so that the user can
        change the default behavior without recompiling.</para>
      </listitem>

      <listitem>
        <para><emphasis>'shall_we_branch_default'</emphasis> - integer
        (USER__BRANCH_IF_MUST - 2). Determines the default branching behavior.
        Other values are USER__DO_NOT_BRANCH - 0 (not recommended as a
        default), USER__DO_BRANCH - 1 (also not recommended as a default), and
        USER__BRANCH_IF_TAILOFF - 3. This parameter is provided so that the
        user can change the default behavior without recompiling.</para>
      </listitem>

      <listitem>
        <para><emphasis>'select_candidates_default'</emphasis> - integer
        (USER__CLOSE_TO_HALF_AND_EXPENSIVE - 10). Determines the default rule
        for selecting strong branching candidates. Other values are
        USER__CLOSE_TO_HALF - 10 and USER__CLOSE_TO_ONE_AND_CHEAP - 12. This
        parameter is provided so that the user can change the default behavior
        without recompiling.</para>
      </listitem>

      <listitem>
        <para><emphasis>'compare_candidates_default'</emphasis> - integer
        (HIGHEST_LOW_OBJ - 2). Determines the default rule for comparing
        candidates. See the description of user_compare_candidates() for other
        values. This parameter is provided so that the user can change the
        default behavior without recompiling.</para>
      </listitem>

      <listitem>
        <para><emphasis>'select_child_default' </emphasis>- integer
        (PREFER_LOWER_OBJ_VALUE - 0). Determines the default rule for
        selecting the child to be processed next. For other possible values,
        see the description user_select_child(). This parameter is provided so
        that the user can change the default behavior without
        recompiling.</para>
      </listitem>

      <listitem>
        <para><emphasis>'mc_find_supported_solutions'</emphasis> - boolean
        (FALSE - 0). By default, sym_mc_solve routine will find all the
        non-dominated solutions if the problem to be solved is a bicriteria
        problem. However, if the user plans to find only the supported
        solutions, then, this parameter has to be set before calling
        sym_mc_solve routine.</para>
      </listitem>

      <listitem>
        <para><emphasis>'mc_rho'</emphasis> - double (0.00001). The value used
        in augmented Chebyshev norm during the bicriteria solution
        procedure.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_cuts'</emphasis> - boolean (TRUE - 1).
        Whether or not to generate cuts using COIN's cut generation library.
        Note that, to use CGL cuts, OSI interface has to be used and moreover
        the corresponding flags have to be set during installation. See the
        makefile for more details.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_gomory_cuts' </emphasis>- boolean (TRUE
        - 1). Whether or not to generate Gomory cuts using COIN's cut
        generation library.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_knapsack_cuts'</emphasis> - boolean
        (TRUE - 1). Whether or not to generate knapsack cover cuts using
        COIN's cut generation library.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_oddhole_cuts'</emphasis> - boolean (TRUE
        - 1). Whether or not to generate generalized odd hole cuts using
        COIN's cut generation library.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_probing_cuts'</emphasis> - boolean (TRUE
        - 1). Whether or not to generate probing cuts using COIN's cut
        generation library.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_clique_cuts'</emphasis> - boolean (TRUE
        - 1). Whether or not to generate clique cuts using COIN's cut
        generation library.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_flow_and_cover_cuts'</emphasis> -
        boolean (FALSE - 0). Whether or not to generate flow and cover cuts
        using COIN's cut generation library.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_rounding_cuts'</emphasis> - boolean
        (FALSE - 0). Whether or not to generate simple rounding cuts using
        COIN's cut generation library.</para>
      </listitem>

      <listitem>
        <para><emphasis>'generate_cgl_lift_and_project_cuts'</emphasis> -
        boolean (FALSE - 0). Whether or not to generate lift-andproject cuts
        using COIN's cut generation library.</para>
      </listitem>
    </itemizedlist>

    <para>Cut generator parameters:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>'CG_verbosity'</emphasis> - integer (0). Verbosity
        level for the cut generator module.</para>
      </listitem>
    </itemizedlist>

    <para>Cut pool parameters:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>'CP_verbosity' </emphasis>- integer (0). Verbosity of
        the cut pool module.</para>
      </listitem>

      <listitem>
        <para><emphasis>'cp_logging'</emphasis> - boolean (0). Determines
        whether the logging option is enabled. In this case, the entire
        contents of the cut pool are written out periodically to disk (at the
        same interval as the tree manager log files are written). If this
        option is set, then the line following must start with the keyword
        cp_log_file_name and include the appropriate file name as the
        value.</para>
      </listitem>

      <listitem>
        <para><emphasis>'cp_warm_start'</emphasis> - boolean (0). Used to
        allow the cut pool to make a warm start by reading in a previously
        written log file. If this option is set, then the line following must
        start with the keyword cp_warm_start_file_name and include the
        appropriate file name as the value.</para>
      </listitem>

      <listitem>
        <para><emphasis>'block_size'</emphasis> - integer (5000). Indicates
        the size of the blocks to allocate when more space is needed in the
        cut list.</para>
      </listitem>

      <listitem>
        <para><emphasis>'max_size'</emphasis> - integer (2000000). Indicates
        the maximum size of the cut pool in bytes. This is the total memory
        taken up by the cut list, including all data structures and the array
        of pointers itself.</para>
      </listitem>

      <listitem>
        <para><emphasis>'max_number_of_cuts'</emphasis> - integer (10000).
        Indicates the maximum number of cuts allowed to be stored. When this
        max is reached, cuts are forcibly purged, starting with duplicates and
        then those indicated by the parameter delete_which (see below), until
        the list is below the allowable size.</para>
      </listitem>

      <listitem>
        <para><emphasis>'min_to_delete' </emphasis>- integer (1000). Indicates
        the number of cuts required to be deleted when the pool reaches it's
        maximum size.</para>
      </listitem>

      <listitem>
        <para><emphasis>'touches_until_deletion'</emphasis> - integer (10).
        When using the number of touches a cut has as a measure of its
        quality, this parameter indicates the number of touches a cut can have
        before being deleted from the pool. The number of touches is the
        number of times in a row that a cut has been checked without being
        found to be violated. It is a measure of a cut's relevance or
        effectiveness.</para>
      </listitem>

      <listitem>
        <para><emphasis>'delete_which'</emphasis> - integer (DELETE_BY_TOUCHES
        - 2). Indicates which cuts to delete when purging the pool.
        DELETE_BY_TOUCHES - 2 indicates that cuts whose number of touches is
        above the threshold (see touches_until_deletion above) should be
        purged if the pool gets too large. DELETE_BY_QUALITY - 1 indicates
        that a user-defined measure of quality should be used (see the
        function user_check_cuts in Section 6.3.4 of the Symphony
        documentation).</para>
      </listitem>

      <listitem>
        <para><emphasis>'check_which'</emphasis> - integer (CHECK_ALL_CUTS -
        0). Indicates which cuts should be checked for violation. The choices
        are to check all cuts (CHECK_ALL_CUTS - 0); only those that have
        number of touches below the threshold (CHECK_TOUCHES - 2); only those
        that were generated at a level higher in the tree than the current one
        (CHECK_LEVEL - 1); or both (CHECK_LEVEL_AND_TOUCHES - 3). Note that
        with CHECK_ALL_CUTS - 0 set, SYMPHONY will still only check the first
        cuts to check cuts in the list ordered by quality (see the function
        user_check_cut).</para>
      </listitem>

      <listitem>
        <para><emphasis>'cuts_to_check'</emphasis> - integer (1000). Indicates
        how many cuts in the pool to actually check. The list is ordered by
        quality and the first cuts to check cuts are checked for
        violation.</para>
      </listitem>
    </itemizedlist>

    <para>The parameters used by the symphony 'extra' output structure are the
    following:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>lambda</emphasis> the Lagrangian coefficients of the
        problem.</para>
      </listitem>

      <listitem>
        <para><emphasis>sym_status</emphasis> an array of bits which gives
        more informations on the state of the solver:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>bit 1</emphasis>: true if is proven optimal</para>
          </listitem>

          <listitem>
            <para><emphasis>bit 2</emphasis>: true if is proven primal
            infeasible</para>
          </listitem>

          <listitem>
            <para><emphasis>bit 3</emphasis>: true if target gap has been
            achieved</para>
          </listitem>

          <listitem>
            <para><emphasis>bit 4</emphasis>: true if is abandoned</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para><emphasis>iterations</emphasis> the number of nodes
        explored.</para>
      </listitem>
    </itemizedlist>
  </refsection>

  <refsection>
    <title>Description</title>

    <para>Solve the following mixed integer linear programming problem:</para>

    <latex style="display" align="center"><![CDATA[ 
\begin{eqnarray}
\mbox{min} & \left[c_{1}^{t}\cdot x,c_{2}^{t}\cdot x\right] & \\
\mbox{subject to} & A_{1}\cdot x=b_{1} & \\
 & A_{2}\cdot x\leq b_{2} & \\
 & x_{i}^{\mbox{min}}\leq x_{i}\leq x_{i}^{\mbox{max}} & i=1,\cdots,m\\
\mbox{and} & x_{j}\in D\subset\mathbb{N} & j=m+1,\cdots,n
\end{eqnarray}
]]></latex>

    <para>This tool is based on the Symphony solver (see
    <ulink url="http://www.coin-or.org">http://www.coin-or.org</ulink> - Symphony project). It supports sparse matrix for
    the constraints, bicriteria objective functions, etc ...</para>
  </refsection>

  <refsection>
    <title>Example</title>

    <programlisting role="example"><![CDATA[ 
c = [10, 6, 4];
a = [1,  1, 1;...
     10, 4, 5;...
     2,  2, 6];
b = [100,600,300]';
lb    = [0,0,0];
ub    = [100,100,100];
vartype = 'CCC'; // Continuous variables
constrtype = 'LLL'; // Upper bounds

param = init_param();
param = add_param(param, 'verbosity', 3);
param = add_param(param, 'problem_type', 2);
param = add_param(param, 'time_limit', 1000);    
param = add_param(param, 'node_limit', 10000);
param = add_param(param, 'find_first_feasible', 1);

[xmin,lambda,status] = symphony(c,[],a,b,b,lb,ub,constrtype,vartype,param);

printf('solution found: \n');disp(xmin);
printf('Objective function value = %f\n', fmin);
printf('Lambda = '); disp(lambda);

printf('Status of problem: %d\n', status);
printf('Secondary status of problem - may get extended: %d \n', extra('sym_status'));
printf('Nodes explorer: %d\n', extra('iterations'));
 ]]></programlisting>
  </refsection>

  <refsection>
    <title>Authors</title>

    <simplelist type="vert">
      <member>Yann COLLETTE</member>
    </simplelist>
  </refsection>
</refentry>
